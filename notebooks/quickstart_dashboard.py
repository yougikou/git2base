"""Utilities for building an interactive statistics dashboard inside Jupyter.

This module provides a lightweight framework that turns the CSV outputs
generated by Git2Base into a navigable statistics dashboard.  It focuses on
four concerns:

* selecting a project (repository) and its analysis runs
* splitting statistics per repository into tech-stack tabs based on
  ``config/config.yaml``
* rendering statistics for a single run
* rendering trend charts that aggregate data across runs

The goal of the framework is to make it easy to plug in new statistics without
having to re-create the surrounding widget wiring every time.  Typical usage in
Jupyter looks like::

    from quickstart_dashboard import QuickstartDashboard, RecordCountStatistic

    dashboard = QuickstartDashboard(base_dir="../artifacts")
    dashboard.register_statistic(
        RecordCountStatistic()
    )
    dashboard.show()

After the dashboard is displayed you can switch between projects, pick a run to
inspect the statistics of that execution, and check the trend analysis tab for
historical context.

The bundled :class:`RecordCountStatistic` inspects each run's ``run_type``
metadata to choose between ``commit_files.csv`` and ``diff_results.csv`` so it
can report a meaningful row count without any manual configuration.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence

import ipywidgets as widgets
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display
import yaml


# ---------------------------------------------------------------------------
# Data loading utilities
# ---------------------------------------------------------------------------


CSV_FILE_MAP: Dict[str, str] = {
    "commit_files.csv": "commit_files_df",
    "diff_results.csv": "diff_results_df",
    "analysis_results.csv": "analysis_results_df",
    "commits.csv": "commits_df",
}


DEFAULT_CONFIG_PATH = (
    Path(__file__).resolve().parents[1] / "config" / "config.yaml"
)


@dataclass
class TechStackDefinition:
    """Single tech stack entry loaded from ``config.yaml``."""

    name: str
    path_prefixes: List[str]
    extensions: set[str]

    def matches(self, normalized_path: str, extension: str) -> bool:
        if not normalized_path:
            return False

        if self.extensions and extension:
            if extension in self.extensions:
                return True

        if self.path_prefixes:
            for prefix in self.path_prefixes:
                if normalized_path == prefix or normalized_path.startswith(prefix + "/"):
                    return True

        return False


class TechStackClassifier:
    """Classify file paths into configured tech stacks."""

    def __init__(
        self,
        stacks: Sequence[TechStackDefinition],
        *,
        all_label: str = "全部",
        uncategorized_label: str = "未分类",
        include_uncategorized: bool = True,
    ) -> None:
        self._stacks = list(stacks)
        self.all_label = all_label
        self.uncategorized_label = uncategorized_label
        self.include_uncategorized = include_uncategorized and bool(self._stacks)

    @classmethod
    def from_config(cls, path: Path | str | None = None) -> "TechStackClassifier":
        config_path = Path(path or DEFAULT_CONFIG_PATH).expanduser().resolve()
        stacks: List[TechStackDefinition] = []

        if config_path.exists():
            try:
                with config_path.open("r", encoding="utf-8") as handle:
                    config = yaml.safe_load(handle) or {}
            except Exception as exc:  # pragma: no cover - defensive logging
                print(f"⚠️ Failed to read config from {config_path}: {exc}")
                config = {}
        else:
            config = {}

        for entry in config.get("stacks", []) or []:
            if not isinstance(entry, dict):
                continue
            name = str(entry.get("name") or "").strip()
            if not name:
                continue

            raw_paths = entry.get("paths") or []
            raw_exts = entry.get("extensions") or []

            path_prefixes = [
                str(item).strip().replace("\\", "/").strip("/").lower()
                for item in raw_paths
                if str(item).strip()
            ]
            extensions = {
                str(item).strip().lstrip(".").lower()
                for item in raw_exts
                if str(item).strip()
            }

            stacks.append(
                TechStackDefinition(
                    name=name,
                    path_prefixes=path_prefixes,
                    extensions=extensions,
                )
            )

        include_uncategorized = bool(stacks)
        return cls(
            stacks,
            include_uncategorized=include_uncategorized,
        )

    @property
    def stack_labels(self) -> List[str]:
        labels = [self.all_label]
        labels.extend(stack.name for stack in self._stacks)
        if self.include_uncategorized:
            labels.append(self.uncategorized_label)
        return labels

    def is_all(self, label: str) -> bool:
        return label == self.all_label

    def is_uncategorized(self, label: str) -> bool:
        return self.include_uncategorized and label == self.uncategorized_label

    def classify_path(self, path: str) -> Optional[str]:
        normalized = (path or "").strip().replace("\\", "/").strip("/")
        if not normalized:
            return None

        lowered_path = normalized.lower()
        extension = Path(lowered_path).suffix.lstrip(".")

        for stack in self._stacks:
            if stack.matches(lowered_path, extension):
                return stack.name
        return None

    def filter_dataframe(self, df: pd.DataFrame, stack_label: str) -> pd.DataFrame:
        if df is None:
            return df

        if self.is_all(stack_label):
            return df

        path_series = self._extract_path_series(df)
        if path_series is None:
            return df

        classifications = path_series.apply(self.classify_path)
        if self.is_uncategorized(stack_label):
            mask = classifications.isna()
        else:
            mask = classifications == stack_label
        return df.loc[mask].copy()

    def filter_run_dataframes(
        self, dataframes: Dict[str, pd.DataFrame], stack_label: str
    ) -> Dict[str, pd.DataFrame]:
        if self.is_all(stack_label):
            return dataframes

        filtered: Dict[str, pd.DataFrame] = {}
        for key, df in dataframes.items():
            filtered[key] = self.filter_dataframe(df, stack_label)
        return filtered

    def _extract_path_series(self, df: pd.DataFrame) -> Optional[pd.Series]:
        candidates: Iterable[str] = (
            "target_path",
            "path",
            "file_path",
        )

        for column in candidates:
            if column in df.columns:
                series = df[column].fillna("").astype(str)
                if column == "target_path" and "source_path" in df.columns:
                    source_series = df["source_path"].fillna("").astype(str)
                    series = series.where(series != "", source_series)
                return series
        return None


def _parse_run_timestamp(name: str) -> Optional[datetime]:
    """Best-effort parsing of timestamps encoded in run folder names."""

    patterns = [
        "%Y%m%d-%H%M%S",
        "%Y%m%d_%H%M%S",
        "%Y-%m-%d-%H-%M-%S",
        "%Y-%m-%d_%H-%M-%S",
        "%Y%m%d%H%M%S",
    ]

    for pattern in patterns:
        try:
            return datetime.strptime(name, pattern)
        except ValueError:
            continue
    return None


@dataclass
class RunData:
    """Container for the CSV data that belongs to a single analysis run."""

    repo: str
    run: str
    path: Path
    metadata: Dict[str, object]
    dataframes: Dict[str, pd.DataFrame]
    timestamp: Optional[datetime]
    selected_stack: Optional[str] = None

    @property
    def display_label(self) -> str:
        """Human friendly representation for displaying this run in charts."""

        if self.timestamp is not None:
            return self.timestamp.strftime("%Y-%m-%d %H:%M:%S")
        return self.run


@dataclass
class RunHistory:
    """All historical runs for a repository in chronological order."""

    repo: str
    runs: List[RunData] = field(default_factory=list)

    def ensure_sorted(self) -> None:
        """Sort runs chronologically (oldest first)."""

        self.runs.sort(key=lambda r: (r.timestamp or datetime.min, r.run))


class RunDataLoader:
    """Helper responsible for listing repositories and loading CSV outputs."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        csv_file_map: Optional[Dict[str, str]] = None,
    ) -> None:
        self.base_dir = Path(base_dir).expanduser().resolve()
        self.csv_file_map = csv_file_map or CSV_FILE_MAP

    # -- discovery -----------------------------------------------------

    def list_repos(self) -> List[str]:
        if not self.base_dir.exists():
            return []
        return sorted(
            {item.name for item in self.base_dir.iterdir() if item.is_dir()}
        )

    def list_runs(self, repo: str) -> List[str]:
        run_dir = self.base_dir / repo / "runs"
        if not run_dir.exists():
            return []

        runs = [item.name for item in run_dir.iterdir() if item.is_dir()]
        # Sort newest first when selecting individual runs to inspect
        runs.sort(reverse=True)
        return runs

    # -- loading -------------------------------------------------------

    def load_run(self, repo: str, run: str) -> Optional[RunData]:
        data_dir = self.base_dir / repo / "runs" / run / "data"
        if not data_dir.exists():
            return None

        dataframes: Dict[str, pd.DataFrame] = {}
        for file_name, key in self.csv_file_map.items():
            csv_path = data_dir / file_name
            if csv_path.exists():
                try:
                    dataframes[key] = pd.read_csv(csv_path)
                except Exception as exc:  # pragma: no cover - defensive logging
                    print(f"⚠️ Failed to read {csv_path}: {exc}")

        metadata = self._load_run_metadata(repo, run)
        run_timestamp = _parse_run_timestamp(run)
        return RunData(
            repo=repo,
            run=run,
            path=data_dir,
            metadata=metadata,
            dataframes=dataframes,
            timestamp=run_timestamp,
        )

    def load_history(
        self, repo: str, limit: Optional[int] = None, eager: bool = True
    ) -> RunHistory:
        """Load RunData instances for all runs of a repository."""

        history = RunHistory(repo=repo)
        runs = self.list_runs(repo)
        if limit is not None:
            runs = runs[:limit]

        for run_name in runs:
            if eager:
                run_data = self.load_run(repo, run_name)
            else:
                run_data = RunData(
                    repo=repo,
                    run=run_name,
                    path=self.base_dir / repo / "runs" / run_name / "data",
                    metadata=self._load_run_metadata(repo, run_name),
                    dataframes={},
                    timestamp=_parse_run_timestamp(run_name),
                )
            if run_data is not None:
                history.runs.append(run_data)

        history.ensure_sorted()
        return history

    def _load_run_metadata(self, repo: str, run: str) -> Dict[str, object]:
        metadata_path = self.base_dir / repo / "runs" / run / "run.json"
        if not metadata_path.exists():
            return {}

        try:
            with metadata_path.open("r", encoding="utf-8") as handle:
                raw = handle.read()
            if not raw.strip():
                return {}
            return json.loads(raw)
        except Exception as exc:  # pragma: no cover - defensive logging
            print(f"⚠️ Failed to read {metadata_path}: {exc}")
            return {}


# ---------------------------------------------------------------------------
# Statistics building blocks
# ---------------------------------------------------------------------------


class BaseStatistic:
    """Interface for statistics that can be rendered by the dashboard."""

    name: str

    def render_single(self, run: RunData) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError

    def render_trend(self, history: RunHistory) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError


def _card_container(
    title: str,
    *,
    description: str | None = None,
    body_html: str | None = None,
    body_widgets: widgets.Widget | Sequence[widgets.Widget] | None = None,
    min_width: str = "220px",
    flex: str = "1 1 240px",
) -> widgets.Widget:
    """Render a card with a consistent border/padding layout."""

    header_parts = [
        f"<div style='font-size:12px;color:#666;'>{title}</div>",
    ]
    if description:
        header_parts.append(
            f"<div style='font-size:11px;color:#999;margin-top:2px;'>{description}</div>"
        )

    children: List[widgets.Widget] = [
        widgets.HTML(value="".join(header_parts))
    ]

    if body_html:
        children.append(widgets.HTML(value=body_html))

    if body_widgets is not None:
        if isinstance(body_widgets, widgets.Widget):
            children.append(body_widgets)
        else:
            for item in body_widgets:
                children.append(item)

    layout = widgets.Layout(
        padding="12px 16px",
        border_top="1px solid #ddd",
        border_right="1px solid #ddd",
        border_bottom="1px solid #ddd",
        border_left="1px solid #ddd",
        margin="0 12px 12px 0",
        min_width=min_width,
        width="auto",
        flex=flex,
        display="flex",
        flex_flow="column",
    )

    return widgets.VBox(children, layout=layout)


def _stat_card(title: str, value: str, description: str | None = None) -> widgets.Widget:
    body_html = f"<div style='font-size:26px;font-weight:bold;margin-top:6px;'>{value}</div>"
    return _card_container(
        title,
        description=description,
        body_html=body_html,
        min_width="200px",
        flex="1 1 200px",
    )


class RecordCountStatistic(BaseStatistic):
    """Row-count statistic that adapts to snapshot and diff runs automatically."""

    def __init__(self) -> None:
        self.name = "记录数"
        self.description = "根据运行类型自动选择表格并统计行数"

    def _resolve_table_key(self, run: RunData) -> Optional[str]:
        run_type = (run.metadata or {}).get("run_type")
        if run_type == "snapshot":
            return "commit_files_df"
        if run_type == "diff":
            return "diff_results_df"

        if "commit_files_df" in run.dataframes:
            return "commit_files_df"
        if "diff_results_df" in run.dataframes:
            return "diff_results_df"
        return None

    def _extract(self, run: RunData) -> Optional[int]:
        table_key = self._resolve_table_key(run)
        if table_key is None:
            return None

        df = run.dataframes.get(table_key)
        if df is None:
            return None
        return int(df.shape[0])

    def render_single(self, run: RunData) -> widgets.Widget:
        value = self._extract(run)
        display_value = f"{value}" if value is not None else "N/A"
        return _stat_card(self.name, display_value, self.description)

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        for run in history.runs:
            value = self._extract(run)
            if value is not None:
                records.append(
                    {
                        "label": run.display_label,
                        "value": value,
                        "timestamp": run.timestamp,
                    }
                )

        if not records:
            return _card_container(
                self.name,
                description=self.description,
                body_html=(
                    f"<div style='color:#666;'>暂无 {self.name} 的历史数据可以展示。</div>"
                ),
                min_width="320px",
                flex="1 1 100%",
            )

        df = pd.DataFrame(records)
        df.sort_values(by="timestamp", inplace=True)

        output = widgets.Output()
        with output:
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(df["label"], df["value"], marker="o")
            ax.set_title(self.name)
            ax.set_xlabel("Run")
            ax.set_ylabel("Count")
            ax.grid(True, linestyle="--", alpha=0.3)
            plt.xticks(rotation=30, ha="right")
            plt.tight_layout()
            display(fig)
            plt.close(fig)

        return _card_container(
            self.name,
            description=self.description,
            body_widgets=output,
            min_width="320px",
            flex="1 1 100%",
        )


class DiffFileChangeCountStatistic(BaseStatistic):
    """Summarize added/changed/deleted file counts for diff runs."""

    def __init__(self) -> None:
        self.name = "变更文件统计"
        self.description = "针对 diff 运行统计新增/变更/删除的文件数量"

    def _extract(self, run: RunData) -> Optional[dict[str, int]]:
        run_type = (run.metadata or {}).get("run_type")
        if run_type != "diff":
            return None

        diff_df = run.dataframes.get("diff_results_df")
        if diff_df is None:
            return None

        if "diff_change_type" not in diff_df.columns:
            return None

        series = diff_df["diff_change_type"].fillna("").astype(str)
        counts = {
            "added": int((series == "A").sum()),
            "changed": int(series.isin({"M", "R"}).sum()),
            "deleted": int((series == "D").sum()),
        }
        return counts

    def render_single(self, run: RunData) -> widgets.Widget:
        run_type = (run.metadata or {}).get("run_type", "")
        counts = self._extract(run) if run_type == "diff" else None

        if run_type != "diff":
            message = f"仅针对 diff 运行展示，当前运行类型为 {run_type or '未知'}。"
            return _card_container(
                self.name,
                description=self.description,
                body_html=f"<div style='color:#666;'>{message}</div>",
            )

        if counts is None:
            return _card_container(
                self.name,
                description=self.description,
                body_html="<div style='color:#666;'>未找到 diff 结果，无法统计文件变更数量。</div>",
            )

        mapping = (
            ("新增文件", counts.get("added", 0)),
            ("变更文件", counts.get("changed", 0)),
            ("删除文件", counts.get("deleted", 0)),
        )
        rows = [
            "<table style='border-collapse:collapse;width:100%;font-size:13px;'>",
            "<tbody>",
        ]
        for label, value in mapping:
            rows.append("<tr>")
            rows.append(
                f"<td style='padding:6px 4px;color:#555;'>{label}</td>"
            )
            rows.append(
                f"<td style='padding:6px 4px;text-align:right;font-weight:600;color:#222;'>{value}</td>"
            )
            rows.append("</tr>")
        rows.append("</tbody></table>")

        return _card_container(
            self.name,
            description=self.description,
            body_html="".join(rows),
        )

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        for run in history.runs:
            counts = self._extract(run)
            if counts is None:
                continue
            records.append(
                {
                    "label": run.display_label,
                    "timestamp": run.timestamp,
                    "added": counts["added"],
                    "changed": counts["changed"],
                    "deleted": counts["deleted"],
                }
            )

        if not records:
            return _card_container(
                self.name,
                description=self.description,
                body_html=f"<div style='color:#666;'>暂无 {self.name} 的历史数据可以展示。</div>",
                min_width="320px",
                flex="1 1 100%",
            )

        df = pd.DataFrame(records)
        df.sort_values(by="timestamp", inplace=True)

        output = widgets.Output()
        with output:
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(df["label"], df["added"], marker="o", label="新增")
            ax.plot(df["label"], df["changed"], marker="o", label="变更")
            ax.plot(df["label"], df["deleted"], marker="o", label="删除")
            ax.set_title(self.name)
            ax.set_xlabel("Run")
            ax.set_ylabel("数量")
            ax.grid(True, linestyle="--", alpha=0.3)
            plt.xticks(rotation=30, ha="right")
            ax.legend()
            plt.tight_layout()
            display(fig)
            plt.close(fig)

        return _card_container(
            self.name,
            description=self.description,
            body_widgets=output,
            min_width="320px",
            flex="1 1 100%",
        )


class FileCharCountDistributionStatistic(BaseStatistic):
    """Bucket files by character count and highlight diff additions/modifications."""

    BINS: Sequence[tuple[str, int, Optional[int]]] = (
        ("<1k", 0, 1_000),
        ("1k-2k", 1_000, 2_000),
        ("2k-3k", 2_000, 3_000),
        ("3k-10k", 3_000, 10_000),
        ("10k-50k", 10_000, 50_000),
        (">=50k", 50_000, None),
    )

    def __init__(self) -> None:
        self.name = "文件字符区间"
        self.description = "基于 FileCharCount 分析结果统计字符区间，并区分新增/变更文件数量"

    # -- helpers -----------------------------------------------------------

    def _load_char_counts(self, run: RunData) -> Optional[pd.DataFrame]:
        df = run.dataframes.get("analysis_results_df")
        if df is None or df.empty:
            return None

        if "analyzer_type" not in df.columns or "count" not in df.columns:
            return None

        filtered = df[df["analyzer_type"] == "FileCharCount"].copy()
        if filtered.empty:
            return None

        filtered["count"] = pd.to_numeric(filtered["count"], errors="coerce")
        filtered.dropna(subset=["count"], inplace=True)
        if filtered.empty:
            return None

        if "commit_hash" not in filtered.columns:
            filtered["commit_hash"] = ""
        else:
            filtered["commit_hash"] = filtered["commit_hash"].fillna("").astype(str)

        if "path" not in filtered.columns:
            filtered["path"] = ""
        else:
            filtered["path"] = filtered["path"].fillna("").astype(str)
        return filtered

    def _attach_diff_metadata(self, run: RunData, df: pd.DataFrame) -> tuple[pd.DataFrame, str, bool]:
        run_type = (run.metadata or {}).get("run_type", "")
        df = df.copy()
        diff_info_available = False

        if run_type == "diff":
            diff_df = run.dataframes.get("diff_results_df")
            if diff_df is not None and not diff_df.empty:
                diff_df = diff_df.copy()
                for column in (
                    "target_path",
                    "source_path",
                    "diff_change_type",
                ):
                    if column not in diff_df.columns:
                        diff_df[column] = ""

                diff_df["target_path"] = diff_df["target_path"].fillna("").astype(str)
                diff_df["source_path"] = diff_df["source_path"].fillna("").astype(str)
                diff_df["diff_change_type"] = diff_df["diff_change_type"].fillna("").astype(str)

                diff_df["_merge_path"] = diff_df["target_path"].where(
                    diff_df["target_path"] != "",
                    diff_df["source_path"],
                )
                diff_map = (
                    diff_df[["_merge_path", "diff_change_type"]]
                    .rename(columns={"_merge_path": "path"})
                    .drop_duplicates(subset=["path"])
                )

                df = df.merge(diff_map, on="path", how="left")
                df["diff_change_type"] = df["diff_change_type"].replace("", pd.NA)
                if df["diff_change_type"].notna().any():
                    diff_info_available = True
            else:
                df["diff_change_type"] = pd.NA
        else:
            df["diff_change_type"] = pd.NA

        return df, str(run_type), diff_info_available

    def _bucket_label(self, value: float) -> str:
        for label, lower, upper in self.BINS:
            if value < lower:
                continue
            if upper is None or value < upper:
                return label
        return self.BINS[-1][0]

    def _summaries(self, run: RunData) -> Optional[dict[str, object]]:
        base_df = self._load_char_counts(run)
        if base_df is None:
            return None

        df, run_type, diff_info_available = self._attach_diff_metadata(run, base_df)
        if df.empty:
            return None

        df["range_label"] = df["count"].apply(self._bucket_label)

        rows: List[dict[str, object]] = []
        for label, _, _ in self.BINS:
            subset = df[df["range_label"] == label]
            total = int(subset.shape[0])
            added: Optional[int] = None
            changed: Optional[int] = None

            if run_type == "diff" and diff_info_available:
                added = int(subset["diff_change_type"].isin({"A"}).sum())
                changed = int(subset["diff_change_type"].isin({"M", "R"}).sum())

            rows.append(
                {
                    "range": label,
                    "total": total,
                    "added": added,
                    "changed": changed,
                }
            )

        return {
            "rows": rows,
            "run_type": run_type,
            "diff_info": diff_info_available,
        }

    def _render_distribution_table(self, rows: Sequence[dict[str, object]], diff_info: bool) -> widgets.HTML:
        header_cells = ["区间", "文件数", "新增", "变更"]
        html = [
            "<table style='border-collapse:collapse;font-size:12px;width:100%;max-width:520px;'>",
            "<thead><tr>",
        ]
        for cell in header_cells:
            html.append(
                f"<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:left;color:#555;font-weight:600;'>{cell}</th>"
            )
        html.append("</tr></thead><tbody>")

        for row in rows:
            total = row["total"]
            added = row.get("added")
            changed = row.get("changed")
            html.append("<tr>")
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{row['range']}</td>"
            )
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{total}</td>"
            )
            if diff_info:
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{added if added is not None else 0}</td>"
                )
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{changed if changed is not None else 0}</td>"
                )
            else:
                html.append(
                    "<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#999;'>-</td>"
                )
                html.append(
                    "<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#999;'>-</td>"
                )
            html.append("</tr>")

        html.append("</tbody></table>")
        return widgets.HTML(value="".join(html))

    def _render_matrix_table(
        self, title: str, df: pd.DataFrame, label_order: Sequence[str]
    ) -> widgets.HTML:
        if df.empty:
            return widgets.HTML(value="")

        df = df.copy()
        df = df.reindex(self._bin_labels(), axis=0, fill_value=0)
        df = df[[label for label in label_order if label in df.columns]]

        html = [
            f"<div style='font-size:12px;color:#555;font-weight:600;margin:8px 0 4px;'>{title}</div>",
            "<table style='border-collapse:collapse;font-size:12px;width:100%;max-width:720px;'>",
            "<thead><tr>",
            "<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:left;color:#555;font-weight:600;'>区间</th>",
        ]
        for col in df.columns:
            html.append(
                f"<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:right;color:#555;font-weight:600;'>{col}</th>"
            )
        html.append("</tr></thead><tbody>")

        for idx in df.index:
            html.append("<tr>")
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{idx}</td>"
            )
            for col in df.columns:
                value = int(df.loc[idx, col]) if pd.notna(df.loc[idx, col]) else ""
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;text-align:right;'>{value}</td>"
                )
            html.append("</tr>")

        html.append("</tbody></table>")
        return widgets.HTML(value="".join(html))

    def _bin_labels(self) -> List[str]:
        return [label for label, _, _ in self.BINS]

    # -- rendering ---------------------------------------------------------

    def render_single(self, run: RunData) -> widgets.Widget:
        summary = self._summaries(run)
        if summary is None:
            return _card_container(
                self.name,
                description=self.description,
                body_html="<div style='color:#666;'>暂无 FileCharCount 分析结果可用于统计。</div>",
                min_width="360px",
            )

        diff_run = summary["run_type"] == "diff"
        diff_info = diff_run and summary["diff_info"]
        if diff_info:
            note = "统计基于 diff 运行匹配的 FileCharCount 结果。"
        elif diff_run:
            note = "diff 运行未匹配到文件级变更，新增/变更列以 “-” 显示。"
        else:
            run_label = summary["run_type"] or "未知"
            note = f"当前运行类型为 {run_label}，新增/变更列以 “-” 显示。"

        table = self._render_distribution_table(summary["rows"], diff_info)
        return _card_container(
            self.name,
            description=self.description,
            body_widgets=[widgets.HTML(value=f"<div style='color:#666;font-size:12px;'>{note}</div>"), table],
            min_width="360px",
        )

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        label_order: List[str] = []
        seen_labels: set[str] = set()
        diff_info_available = False

        for run in history.runs:
            summary = self._summaries(run)
            if summary is None:
                continue

            label = run.display_label
            if label not in seen_labels:
                label_order.append(label)
                seen_labels.add(label)

            for row in summary["rows"]:
                records.append(
                    {
                        "range": row["range"],
                        "total": row["total"],
                        "added": row.get("added"),
                        "changed": row.get("changed"),
                        "label": label,
                        "run_type": summary["run_type"],
                        "diff_info": summary["diff_info"],
                    }
                )

            if summary["run_type"] == "diff" and summary["diff_info"]:
                diff_info_available = True

        if not records:
            return _card_container(
                self.name,
                description=self.description,
                body_html="<div style='color:#666;'>暂无 FileCharCount 历史数据可以展示。</div>",
                min_width="360px",
                flex="1 1 100%",
            )

        df = pd.DataFrame(records)
        df["range"] = pd.Categorical(df["range"], categories=self._bin_labels(), ordered=True)

        pivot_total = (
            df.pivot_table(
                index="range",
                columns="label",
                values="total",
                aggfunc="sum",
                fill_value=0,
                observed=False,
            )
            if not df.empty
            else pd.DataFrame()
        )

        children: List[widgets.Widget] = []

        if not pivot_total.empty:
            children.append(self._render_matrix_table("各运行的文件数量分布", pivot_total, label_order))

        if diff_info_available:
            diff_df = df[(df["run_type"] == "diff") & (df["diff_info"])]
            if not diff_df.empty:
                pivot_added = diff_df.pivot_table(
                    index="range",
                    columns="label",
                    values="added",
                    aggfunc="sum",
                    fill_value=0,
                    observed=False,
                )
                pivot_changed = diff_df.pivot_table(
                    index="range",
                    columns="label",
                    values="changed",
                    aggfunc="sum",
                    fill_value=0,
                    observed=False,
                )

                if not pivot_added.empty:
                    children.append(
                        self._render_matrix_table("新增文件分布", pivot_added, label_order)
                    )
                if not pivot_changed.empty:
                    children.append(
                        self._render_matrix_table("变更文件分布", pivot_changed, label_order)
                    )

        if not children:
            children.append(
                widgets.HTML(value="<div style='color:#666;'>暂无可视化数据。</div>")
            )

        return _card_container(
            self.name,
            description=self.description,
            body_widgets=children,
            min_width="360px",
            flex="1 1 100%",
        )


# ---------------------------------------------------------------------------
# Dashboard orchestration
# ---------------------------------------------------------------------------


@dataclass
class _StackPage:
    stack: str
    container: widgets.Box


@dataclass
class _TrendPage:
    stack_selector: widgets.Dropdown
    statistic_selector: widgets.Dropdown
    run_type_selector: widgets.Dropdown
    run_selector: widgets.SelectMultiple
    output_container: widgets.Box
    container: widgets.VBox


@dataclass
class _RepoPage:
    repo: str
    run_selector: widgets.Dropdown
    stack_pages: List[_StackPage]
    trend_page: _TrendPage
    tab: widgets.Tab
    container: widgets.VBox
    history: Optional[RunHistory] = None


class QuickstartDashboard:
    """High-level dashboard that wires selectors, statistics and layout."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        statistics: Optional[Sequence[BaseStatistic]] = None,
        loader: Optional[RunDataLoader] = None,
        config_path: str | Path | None = None,
    ) -> None:
        self.loader = loader or RunDataLoader(base_dir=base_dir)
        self.statistics: List[BaseStatistic] = list(statistics or [])
        self.repo_pages: List[_RepoPage] = []
        self._root: widgets.Widget | None = None
        self.stack_classifier = TechStackClassifier.from_config(config_path)

    # -- public API ----------------------------------------------------

    def register_statistic(self, stat: BaseStatistic) -> None:
        self.statistics.append(stat)

    def widget(self) -> widgets.Widget:
        """Return the root widget without triggering an automatic display."""

        if self._root is None:
            self._root = self._build()
        return self._root

    def show(self) -> None:
        """Display the dashboard inside the current notebook output cell."""

        display(self.widget())

    def refresh(self) -> None:
        """Reload repository information and update the UI."""

        if self._root is None:
            self._root = self._build()
        else:
            self._root.children = tuple(self._build().children)

    # -- building ------------------------------------------------------

    def _build(self) -> widgets.Widget:
        repos = self.loader.list_repos()
        if not repos:
            return widgets.VBox(
                [
                    widgets.HTML(
                        value=(
                            "<b>未发现任何分析结果</b><br>"
                            "请先运行 Git2Base 并确认结果已保存在 artifacts 目录下。"
                        )
                    )
                ]
            )

        self.repo_pages = [self._create_repo_page(repo) for repo in repos]

        tab = widgets.Tab(children=[page.container for page in self.repo_pages])
        for index, page in enumerate(self.repo_pages):
            tab.set_title(index, page.repo)

        return widgets.VBox([tab])

    def _create_repo_page(self, repo: str) -> _RepoPage:
        runs = self.loader.list_runs(repo)

        run_selector = widgets.Dropdown(
            options=runs,
            description="Run:",
            layout=widgets.Layout(width="60%"),
        )
        if runs:
            run_selector.value = runs[0]
            run_selector.disabled = False
        else:
            run_selector.options = []
            run_selector.value = None
            run_selector.disabled = True

        stack_pages: List[_StackPage] = []
        for stack in self.stack_classifier.stack_labels:
            container = widgets.Box(
                layout=widgets.Layout(display="flex", flex_flow="row wrap")
            )
            stack_pages.append(
                _StackPage(
                    stack=stack,
                    container=container,
                )
            )

        stack_selector = widgets.Dropdown(
            options=self.stack_classifier.stack_labels,
            description="技术栈:",
            layout=widgets.Layout(width="220px"),
        )

        if self.statistics:
            statistic_options = [
                (
                    getattr(stat, "name", stat.__class__.__name__),
                    stat,
                )
                for stat in self.statistics
            ]
            statistic_selector = widgets.Dropdown(
                options=statistic_options,
                description="统计种类:",
                layout=widgets.Layout(width="240px"),
            )
        else:
            statistic_selector = widgets.Dropdown(
                options=[("暂无统计", None)],
                description="统计种类:",
                layout=widgets.Layout(width="240px"),
                disabled=True,
            )

        run_type_selector = widgets.Dropdown(
            options=[("Snapshot", "snapshot"), ("Diff", "diff")],
            description="执行类型:",
            layout=widgets.Layout(width="200px"),
        )

        trend_run_selector = widgets.SelectMultiple(
            options=[],
            description="Run:",
            layout=widgets.Layout(width="60%", height="160px"),
            disabled=True,
        )

        trend_output = widgets.Box(
            layout=widgets.Layout(display="flex", flex_flow="column")
        )

        controls_row = widgets.HBox(
            [stack_selector, statistic_selector, run_type_selector],
            layout=widgets.Layout(flex_flow="row wrap", gap="12px"),
        )
        controls = widgets.VBox(
            [controls_row, trend_run_selector], layout=widgets.Layout(gap="8px")
        )
        trend_container = widgets.VBox(
            [controls, trend_output], layout=widgets.Layout(gap="12px")
        )

        tab_children: List[widgets.Widget] = []
        if stack_pages:
            tab_children.append(stack_pages[0].container)
        tab_children.append(trend_container)
        for stack_page in stack_pages[1:]:
            tab_children.append(stack_page.container)

        tab = widgets.Tab(children=tab_children)
        if stack_pages:
            tab.set_title(0, stack_pages[0].stack)
            start_index = 2
        else:
            start_index = 1
        tab.set_title(1 if stack_pages else 0, "趋势分析")
        for index, stack_page in enumerate(stack_pages[1:], start=start_index):
            tab.set_title(index, stack_page.stack)

        container = widgets.VBox([run_selector, tab], layout=widgets.Layout(gap="12px"))

        trend_page = _TrendPage(
            stack_selector=stack_selector,
            statistic_selector=statistic_selector,
            run_type_selector=run_type_selector,
            run_selector=trend_run_selector,
            output_container=trend_output,
            container=trend_container,
        )

        page = _RepoPage(
            repo=repo,
            run_selector=run_selector,
            stack_pages=stack_pages,
            trend_page=trend_page,
            tab=tab,
            container=container,
        )

        self._initialize_repo_page(page)

        def _on_run_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_repo_single_statistics(page)

        run_selector.observe(_on_run_change, names="value")

        def _on_stack_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_statistics(page)

        stack_selector.observe(_on_stack_change, names="value")

        def _on_stat_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_statistics(page)

        statistic_selector.observe(_on_stat_change, names="value")

        def _on_run_type_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_run_options(page)

        run_type_selector.observe(_on_run_type_change, names="value")

        def _on_trend_runs_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_statistics(page)

        trend_run_selector.observe(_on_trend_runs_change, names="value")

        return page

    # -- updating ------------------------------------------------------

    def _initialize_repo_page(self, page: _RepoPage) -> None:
        page.history = self.loader.load_history(page.repo)
        runs = [run.run for run in (page.history.runs if page.history else [])]

        run_selector = page.run_selector
        run_selector.options = runs
        if runs:
            run_selector.disabled = False
            if run_selector.value not in runs:
                run_selector.value = runs[0]
            self._update_repo_single_statistics(page)
        else:
            run_selector.disabled = True
            run_selector.value = None
            self._update_repo_single_statistics(page)

        trend_page = page.trend_page
        has_runs = bool(runs)
        trend_page.run_type_selector.disabled = not has_runs
        trend_page.run_selector.disabled = not has_runs

        if has_runs:
            available_types = {
                (run.metadata or {}).get("run_type") for run in page.history.runs
            }
            option_values: List[str] = []
            for option in trend_page.run_type_selector.options:
                if isinstance(option, (tuple, list)):
                    option_values.append(option[1])
                else:
                    option_values.append(option)

            selected_type = trend_page.run_type_selector.value
            if selected_type not in option_values and option_values:
                selected_type = option_values[0]

            if available_types:
                for value in option_values:
                    if value in available_types:
                        selected_type = value
                        break

            trend_page.run_type_selector.value = selected_type
            self._update_trend_run_options(page)
        else:
            trend_page.run_selector.options = []
            trend_page.run_selector.value = ()
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>无可展示的历史数据。</div>"),
            )

    def _resolve_run(self, page: _RepoPage, run_name: str) -> Optional[RunData]:
        run_data: Optional[RunData] = None
        if page.history:
            for candidate in page.history.runs:
                if candidate.run == run_name:
                    run_data = candidate
                    break

        if run_data is None:
            run_data = self.loader.load_run(page.repo, run_name)
        return run_data

    def _filter_run_by_stack(self, run: RunData, stack: str) -> RunData:
        if self.stack_classifier.is_all(stack):
            dataframes = dict(run.dataframes)
        else:
            dataframes = self.stack_classifier.filter_run_dataframes(
                run.dataframes, stack
            )
        metadata = dict(run.metadata or {})
        metadata["selected_stack"] = stack
        return RunData(
            repo=run.repo,
            run=run.run,
            path=run.path,
            metadata=metadata,
            dataframes=dataframes,
            timestamp=run.timestamp,
            selected_stack=stack,
        )

    def _update_repo_single_statistics(self, page: _RepoPage) -> None:
        for stack_page in page.stack_pages:
            self._update_stack_single_statistics(page, stack_page)

    def _update_stack_single_statistics(self, page: _RepoPage, stack_page: _StackPage) -> None:
        run_name = page.run_selector.value
        if not run_name:
            stack_page.container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择一个运行。</div>"),
            )
            return

        run_data = self._resolve_run(page, run_name)

        if run_data is None:
            stack_page.container.children = (
                widgets.HTML(
                    value="<div style='color:#d33;'>无法加载该运行的结果，请检查文件是否存在。</div>"
                ),
            )
            return

        filtered_run = self._filter_run_by_stack(run_data, stack_page.stack)
        single_widgets = [stat.render_single(filtered_run) for stat in self.statistics]
        if not single_widgets:
            single_widgets = [
                widgets.HTML(
                    value="<div style='color:#666;'>暂无统计卡片，请通过 register_statistic 添加。</div>"
                )
            ]
        stack_page.container.children = tuple(single_widgets)

    def _update_trend_run_options(self, page: _RepoPage) -> None:
        trend_page = page.trend_page

        if page.history is None or not page.history.runs:
            trend_page.run_selector.options = []
            trend_page.run_selector.value = ()
            trend_page.run_selector.disabled = True
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>无可展示的历史数据。</div>"),
            )
            return

        run_type = trend_page.run_type_selector.value
        available_runs = [
            run.run
            for run in page.history.runs
            if (run.metadata or {}).get("run_type") == run_type
        ]

        selector = trend_page.run_selector
        selector.options = available_runs

        if not available_runs:
            selector.disabled = True
            selector.value = ()
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>所选执行类型没有可用运行。</div>"),
            )
            return

        selector.disabled = False
        current_selection = tuple(value for value in selector.value if value in available_runs)
        if not current_selection:
            selector.value = tuple(available_runs)
        else:
            selector.value = current_selection

        self._update_trend_statistics(page)

    def _update_trend_statistics(self, page: _RepoPage) -> None:
        trend_page = page.trend_page

        if page.history is None or not page.history.runs:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>无可展示的历史数据。</div>"),
            )
            return

        if trend_page.statistic_selector.disabled or not self.statistics:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>暂无趋势统计，请通过 register_statistic 添加。</div>"),
            )
            return

        statistic = trend_page.statistic_selector.value
        if statistic is None:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择要展示的统计种类。</div>"),
            )
            return

        selected_runs = list(trend_page.run_selector.value or [])
        if not selected_runs:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择至少一个运行以展示趋势。</div>"),
            )
            return

        run_type = trend_page.run_type_selector.value
        selected_set = set(selected_runs)
        filtered_runs = [
            run
            for run in page.history.runs
            if run.run in selected_set
            and (run.metadata or {}).get("run_type") == run_type
        ]

        if not filtered_runs:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>所选运行没有历史数据。</div>"),
            )
            return

        stack_label = trend_page.stack_selector.value or self.stack_classifier.all_label
        stack_filtered_runs = [
            self._filter_run_by_stack(run, stack_label) for run in filtered_runs
        ]
        filtered_history = RunHistory(repo=page.repo, runs=stack_filtered_runs)
        filtered_history.ensure_sorted()

        if not filtered_history.runs:
            trend_page.output_container.children = (
                widgets.HTML(value="<div style='color:#666;'>所选技术栈暂无可展示的数据。</div>"),
            )
            return

        widget = statistic.render_trend(filtered_history)
        trend_page.output_container.children = (widget,)


__all__ = [
    "BaseStatistic",
    "DiffFileChangeCountStatistic",
    "FileCharCountDistributionStatistic",
    "QuickstartDashboard",
    "RecordCountStatistic",
    "RunData",
    "RunDataLoader",
    "RunHistory",
    "TechStackClassifier",
]

