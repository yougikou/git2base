"""Utilities for building an interactive statistics dashboard inside Jupyter.

This module provides a lightweight framework that turns the CSV outputs
generated by Git2Base into a navigable statistics dashboard.  It focuses on
three concerns:

* selecting a project (repository) and its analysis runs
* rendering statistics for a single run
* rendering trend charts that aggregate data across runs

The goal of the framework is to make it easy to plug in new statistics without
having to re-create the surrounding widget wiring every time.  Typical usage in
Jupyter looks like::

    from quickstart_dashboard import QuickstartDashboard, RecordCountStatistic

    dashboard = QuickstartDashboard(base_dir="../artifacts")
    dashboard.register_statistic(
        RecordCountStatistic(
            name="Files analysed",
            table_key="commit_files_df",
            description="Number of files processed for each run",
        )
    )
    dashboard.show()

After the dashboard is displayed you can switch between projects, pick a run to
inspect the statistics of that execution, and check the trend analysis tab for
historical context.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Sequence

import ipywidgets as widgets
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display


# ---------------------------------------------------------------------------
# Data loading utilities
# ---------------------------------------------------------------------------


CSV_FILE_MAP: Dict[str, str] = {
    "commit_files.csv": "commit_files_df",
    "diff_results.csv": "diff_results_df",
    "analysis_results.csv": "analysis_results_df",
    "commits.csv": "commits_df",
}


def _parse_run_timestamp(name: str) -> Optional[datetime]:
    """Best-effort parsing of timestamps encoded in run folder names."""

    patterns = [
        "%Y%m%d-%H%M%S",
        "%Y%m%d_%H%M%S",
        "%Y-%m-%d-%H-%M-%S",
        "%Y-%m-%d_%H-%M-%S",
        "%Y%m%d%H%M%S",
    ]

    for pattern in patterns:
        try:
            return datetime.strptime(name, pattern)
        except ValueError:
            continue
    return None


@dataclass
class RunData:
    """Container for the CSV data that belongs to a single analysis run."""

    repo: str
    run: str
    path: Path
    dataframes: Dict[str, pd.DataFrame]
    timestamp: Optional[datetime]

    @property
    def display_label(self) -> str:
        """Human friendly representation for displaying this run in charts."""

        if self.timestamp is not None:
            return self.timestamp.strftime("%Y-%m-%d %H:%M:%S")
        return self.run


@dataclass
class RunHistory:
    """All historical runs for a repository in chronological order."""

    repo: str
    runs: List[RunData] = field(default_factory=list)

    def ensure_sorted(self) -> None:
        """Sort runs chronologically (oldest first)."""

        self.runs.sort(key=lambda r: (r.timestamp or datetime.min, r.run))


class RunDataLoader:
    """Helper responsible for listing repositories and loading CSV outputs."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        csv_file_map: Optional[Dict[str, str]] = None,
    ) -> None:
        self.base_dir = Path(base_dir).expanduser().resolve()
        self.csv_file_map = csv_file_map or CSV_FILE_MAP

    # -- discovery -----------------------------------------------------

    def list_repos(self) -> List[str]:
        if not self.base_dir.exists():
            return []
        return sorted(
            {item.name for item in self.base_dir.iterdir() if item.is_dir()}
        )

    def list_runs(self, repo: str) -> List[str]:
        run_dir = self.base_dir / repo / "runs"
        if not run_dir.exists():
            return []

        runs = [item.name for item in run_dir.iterdir() if item.is_dir()]
        # Sort newest first when selecting individual runs to inspect
        runs.sort(reverse=True)
        return runs

    # -- loading -------------------------------------------------------

    def load_run(self, repo: str, run: str) -> Optional[RunData]:
        data_dir = self.base_dir / repo / "runs" / run / "data"
        if not data_dir.exists():
            return None

        dataframes: Dict[str, pd.DataFrame] = {}
        for file_name, key in self.csv_file_map.items():
            csv_path = data_dir / file_name
            if csv_path.exists():
                try:
                    dataframes[key] = pd.read_csv(csv_path)
                except Exception as exc:  # pragma: no cover - defensive logging
                    print(f"⚠️ Failed to read {csv_path}: {exc}")

        run_timestamp = _parse_run_timestamp(run)
        return RunData(repo=repo, run=run, path=data_dir, dataframes=dataframes, timestamp=run_timestamp)

    def load_history(
        self, repo: str, limit: Optional[int] = None, eager: bool = True
    ) -> RunHistory:
        """Load RunData instances for all runs of a repository."""

        history = RunHistory(repo=repo)
        runs = self.list_runs(repo)
        if limit is not None:
            runs = runs[:limit]

        for run_name in runs:
            if eager:
                run_data = self.load_run(repo, run_name)
            else:
                run_data = RunData(
                    repo=repo,
                    run=run_name,
                    path=self.base_dir / repo / "runs" / run_name / "data",
                    dataframes={},
                    timestamp=_parse_run_timestamp(run_name),
                )
            if run_data is not None:
                history.runs.append(run_data)

        history.ensure_sorted()
        return history


# ---------------------------------------------------------------------------
# Statistics building blocks
# ---------------------------------------------------------------------------


class BaseStatistic:
    """Interface for statistics that can be rendered by the dashboard."""

    name: str

    def render_single(self, run: RunData) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError

    def render_trend(self, history: RunHistory) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError


def _stat_card(title: str, value: str, description: str | None = None) -> widgets.Widget:
    body = [
        f"<div style='font-size:12px;color:#666;'>{title}</div>",
        f"<div style='font-size:26px;font-weight:bold;margin-top:6px;'>{value}</div>",
    ]
    if description:
        body.append(
            f"<div style='font-size:11px;color:#999;margin-top:4px;'>{description}</div>"
        )
    html = "".join(body)
    return widgets.HTML(
        value=(
            "<div style='padding:12px 16px;border:1px solid #ddd;border-radius:8px;"
            "min-width:160px;background:#fafafa;'>"
            f"{html}</div>"
        )
    )


class RecordCountStatistic(BaseStatistic):
    """Simple statistic that counts the rows of a CSV table."""

    def __init__(self, name: str, table_key: str, description: str | None = None) -> None:
        self.name = name
        self.table_key = table_key
        self.description = description

    def _extract(self, run: RunData) -> Optional[int]:
        df = run.dataframes.get(self.table_key)
        if df is None:
            return None
        return int(df.shape[0])

    def render_single(self, run: RunData) -> widgets.Widget:
        value = self._extract(run)
        display_value = f"{value}" if value is not None else "N/A"
        return _stat_card(self.name, display_value, self.description)

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        for run in history.runs:
            value = self._extract(run)
            if value is not None:
                records.append(
                    {
                        "label": run.display_label,
                        "value": value,
                        "timestamp": run.timestamp,
                    }
                )

        if not records:
            return widgets.HTML(
                value=(
                    f"<div style='color:#666;'>暂无 {self.name} 的历史数据可以展示。</div>"
                )
            )

        df = pd.DataFrame(records)
        df.sort_values(by="timestamp", inplace=True)

        output = widgets.Output()
        with output:
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(df["label"], df["value"], marker="o")
            ax.set_title(self.name)
            ax.set_xlabel("Run")
            ax.set_ylabel("Count")
            ax.grid(True, linestyle="--", alpha=0.3)
            plt.xticks(rotation=30, ha="right")
            plt.tight_layout()
            display(fig)
            plt.close(fig)

        description = (
            self.description if self.description is not None else "Row count per run"
        )
        return widgets.VBox(
            [
                widgets.HTML(
                    value=(
                        f"<b>{self.name}</b><div style='color:#666;font-size:11px;'>{description}</div>"
                    )
                ),
                output,
            ]
        )


# ---------------------------------------------------------------------------
# Dashboard orchestration
# ---------------------------------------------------------------------------


@dataclass
class _RepoPage:
    repo: str
    single_run_selector: widgets.Dropdown
    trend_run_selector: widgets.SelectMultiple
    single_container: widgets.Box
    trend_container: widgets.Box
    tab: widgets.Tab
    container: widgets.VBox
    history: Optional[RunHistory] = None


class QuickstartDashboard:
    """High-level dashboard that wires selectors, statistics and layout."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        statistics: Optional[Sequence[BaseStatistic]] = None,
        loader: Optional[RunDataLoader] = None,
    ) -> None:
        self.loader = loader or RunDataLoader(base_dir=base_dir)
        self.statistics: List[BaseStatistic] = list(statistics or [])
        self.repo_pages: List[_RepoPage] = []
        self._root: widgets.Widget | None = None

    # -- public API ----------------------------------------------------

    def register_statistic(self, stat: BaseStatistic) -> None:
        self.statistics.append(stat)

    def show(self) -> widgets.Widget:
        if self._root is None:
            self._root = self._build()
        display(self._root)
        return self._root

    def refresh(self) -> None:
        """Reload repository information and update the UI."""

        if self._root is None:
            self._root = self._build()
        else:
            self._root.children = tuple(self._build().children)

    # -- building ------------------------------------------------------

    def _build(self) -> widgets.Widget:
        repos = self.loader.list_repos()
        if not repos:
            return widgets.VBox(
                [
                    widgets.HTML(
                        value=(
                            "<b>未发现任何分析结果</b><br>"
                            "请先运行 Git2Base 并确认结果已保存在 artifacts 目录下。"
                        )
                    )
                ]
            )

        self.repo_pages = [self._create_repo_page(repo) for repo in repos]

        tab = widgets.Tab(children=[page.container for page in self.repo_pages])
        for index, page in enumerate(self.repo_pages):
            tab.set_title(index, page.repo)

        return widgets.VBox([tab])

    def _create_repo_page(self, repo: str) -> _RepoPage:
        runs = self.loader.list_runs(repo)
        single_selector = widgets.Dropdown(
            options=runs,
            description="Run:",
            layout=widgets.Layout(width="60%"),
        )
        trend_selector = widgets.SelectMultiple(
            options=runs,
            description="Runs:",
            layout=widgets.Layout(width="60%", height="120px"),
        )

        single_container = widgets.Box(
            layout=widgets.Layout(display="flex", flex_flow="row wrap", gap="12px")
        )
        trend_container = widgets.Box(
            layout=widgets.Layout(display="flex", flex_flow="column", gap="18px")
        )

        single_panel = widgets.VBox(
            [single_selector, single_container], layout=widgets.Layout(gap="12px")
        )
        trend_panel = widgets.VBox(
            [trend_selector, trend_container], layout=widgets.Layout(gap="12px")
        )

        tabs = widgets.Tab(children=[single_panel, trend_panel])
        tabs.set_title(0, "单次执行统计")
        tabs.set_title(1, "趋势分析")

        container = widgets.VBox([tabs])
        page = _RepoPage(
            repo=repo,
            single_run_selector=single_selector,
            trend_run_selector=trend_selector,
            single_container=single_container,
            trend_container=trend_container,
            tab=tabs,
            container=container,
        )

        self._initialize_repo_page(page)

        def _on_single_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_single_statistics(page)

        def _on_trend_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_statistics(page)

        single_selector.observe(_on_single_change, names="value")
        trend_selector.observe(_on_trend_change, names="value")
        return page

    # -- updating ------------------------------------------------------

    def _initialize_repo_page(self, page: _RepoPage) -> None:
        page.history = self.loader.load_history(page.repo)
        runs = [run.run for run in (page.history.runs if page.history else [])]

        page.single_run_selector.options = runs
        page.trend_run_selector.options = runs

        if runs:
            if page.single_run_selector.value not in runs:
                page.single_run_selector.value = runs[0]
            if not page.trend_run_selector.value:
                page.trend_run_selector.value = tuple(runs)
        else:
            page.single_run_selector.value = None
            page.trend_run_selector.value = ()

        self._update_single_statistics(page)
        self._update_trend_statistics(page)

    def _update_single_statistics(self, page: _RepoPage) -> None:
        run_name = page.single_run_selector.value
        if not run_name:
            page.single_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择一个运行。</div>"),
            )
            return

        run_data: Optional[RunData] = None
        if page.history:
            for candidate in page.history.runs:
                if candidate.run == run_name:
                    run_data = candidate
                    break

        if run_data is None:
            run_data = self.loader.load_run(page.repo, run_name)

        if run_data is None:
            page.single_container.children = (
                widgets.HTML(
                    value="<div style='color:#d33;'>无法加载该运行的结果，请检查文件是否存在。</div>"
                ),
            )
            return

        single_widgets = [stat.render_single(run_data) for stat in self.statistics]
        if not single_widgets:
            single_widgets = [
                widgets.HTML(
                    value="<div style='color:#666;'>暂无统计卡片，请通过 register_statistic 添加。</div>"
                )
            ]
        page.single_container.children = tuple(single_widgets)

    def _update_trend_statistics(self, page: _RepoPage) -> None:
        if page.history is None:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>无可展示的历史数据。</div>"),
            )
            return

        selected_runs = list(page.trend_run_selector.value or [])
        if not selected_runs:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择至少一个运行以展示趋势。</div>"),
            )
            return

        selected = set(selected_runs)
        filtered_runs = [run for run in page.history.runs if run.run in selected]
        if not filtered_runs:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>所选运行没有历史数据。</div>"),
            )
            return

        filtered_history = RunHistory(repo=page.repo, runs=list(filtered_runs))
        filtered_history.ensure_sorted()

        trend_widgets = [stat.render_trend(filtered_history) for stat in self.statistics]
        if not trend_widgets:
            trend_widgets = [
                widgets.HTML(
                    value="<div style='color:#666;'>暂无趋势统计，请通过 register_statistic 添加。</div>"
                )
            ]
        page.trend_container.children = tuple(trend_widgets)


__all__ = [
    "BaseStatistic",
    "QuickstartDashboard",
    "RecordCountStatistic",
    "RunData",
    "RunDataLoader",
    "RunHistory",
]

