"""Utilities for building an interactive statistics dashboard inside Jupyter.

This module provides a lightweight framework that turns the CSV outputs
generated by Git2Base into a navigable statistics dashboard.  It focuses on
three concerns:

* selecting a project (repository) and its analysis runs
* rendering statistics for a single run
* rendering trend charts that aggregate data across runs

The goal of the framework is to make it easy to plug in new statistics without
having to re-create the surrounding widget wiring every time.  Typical usage in
Jupyter looks like::

    from quickstart_dashboard import QuickstartDashboard, RecordCountStatistic

    dashboard = QuickstartDashboard(base_dir="../artifacts")
    dashboard.register_statistic(
        RecordCountStatistic()
    )
    dashboard.show()

After the dashboard is displayed you can switch between projects, pick a run to
inspect the statistics of that execution, and check the trend analysis tab for
historical context.

The bundled :class:`RecordCountStatistic` inspects each run's ``run_type``
metadata to choose between ``commit_files.csv`` and ``diff_results.csv`` so it
can report a meaningful row count without any manual configuration.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Sequence

import ipywidgets as widgets
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display


# ---------------------------------------------------------------------------
# Data loading utilities
# ---------------------------------------------------------------------------


CSV_FILE_MAP: Dict[str, str] = {
    "commit_files.csv": "commit_files_df",
    "diff_results.csv": "diff_results_df",
    "analysis_results.csv": "analysis_results_df",
    "commits.csv": "commits_df",
}


def _parse_run_timestamp(name: str) -> Optional[datetime]:
    """Best-effort parsing of timestamps encoded in run folder names."""

    patterns = [
        "%Y%m%d-%H%M%S",
        "%Y%m%d_%H%M%S",
        "%Y-%m-%d-%H-%M-%S",
        "%Y-%m-%d_%H-%M-%S",
        "%Y%m%d%H%M%S",
    ]

    for pattern in patterns:
        try:
            return datetime.strptime(name, pattern)
        except ValueError:
            continue
    return None


@dataclass
class RunData:
    """Container for the CSV data that belongs to a single analysis run."""

    repo: str
    run: str
    path: Path
    metadata: Dict[str, object]
    dataframes: Dict[str, pd.DataFrame]
    timestamp: Optional[datetime]

    @property
    def display_label(self) -> str:
        """Human friendly representation for displaying this run in charts."""

        if self.timestamp is not None:
            return self.timestamp.strftime("%Y-%m-%d %H:%M:%S")
        return self.run


@dataclass
class RunHistory:
    """All historical runs for a repository in chronological order."""

    repo: str
    runs: List[RunData] = field(default_factory=list)

    def ensure_sorted(self) -> None:
        """Sort runs chronologically (oldest first)."""

        self.runs.sort(key=lambda r: (r.timestamp or datetime.min, r.run))


class RunDataLoader:
    """Helper responsible for listing repositories and loading CSV outputs."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        csv_file_map: Optional[Dict[str, str]] = None,
    ) -> None:
        self.base_dir = Path(base_dir).expanduser().resolve()
        self.csv_file_map = csv_file_map or CSV_FILE_MAP

    # -- discovery -----------------------------------------------------

    def list_repos(self) -> List[str]:
        if not self.base_dir.exists():
            return []
        return sorted(
            {item.name for item in self.base_dir.iterdir() if item.is_dir()}
        )

    def list_runs(self, repo: str) -> List[str]:
        run_dir = self.base_dir / repo / "runs"
        if not run_dir.exists():
            return []

        runs = [item.name for item in run_dir.iterdir() if item.is_dir()]
        # Sort newest first when selecting individual runs to inspect
        runs.sort(reverse=True)
        return runs

    # -- loading -------------------------------------------------------

    def load_run(self, repo: str, run: str) -> Optional[RunData]:
        data_dir = self.base_dir / repo / "runs" / run / "data"
        if not data_dir.exists():
            return None

        dataframes: Dict[str, pd.DataFrame] = {}
        for file_name, key in self.csv_file_map.items():
            csv_path = data_dir / file_name
            if csv_path.exists():
                try:
                    dataframes[key] = pd.read_csv(csv_path)
                except Exception as exc:  # pragma: no cover - defensive logging
                    print(f"⚠️ Failed to read {csv_path}: {exc}")

        metadata = self._load_run_metadata(repo, run)
        run_timestamp = _parse_run_timestamp(run)
        return RunData(
            repo=repo,
            run=run,
            path=data_dir,
            metadata=metadata,
            dataframes=dataframes,
            timestamp=run_timestamp,
        )

    def load_history(
        self, repo: str, limit: Optional[int] = None, eager: bool = True
    ) -> RunHistory:
        """Load RunData instances for all runs of a repository."""

        history = RunHistory(repo=repo)
        runs = self.list_runs(repo)
        if limit is not None:
            runs = runs[:limit]

        for run_name in runs:
            if eager:
                run_data = self.load_run(repo, run_name)
            else:
                run_data = RunData(
                    repo=repo,
                    run=run_name,
                    path=self.base_dir / repo / "runs" / run_name / "data",
                    metadata=self._load_run_metadata(repo, run_name),
                    dataframes={},
                    timestamp=_parse_run_timestamp(run_name),
                )
            if run_data is not None:
                history.runs.append(run_data)

        history.ensure_sorted()
        return history

    def _load_run_metadata(self, repo: str, run: str) -> Dict[str, object]:
        metadata_path = self.base_dir / repo / "runs" / run / "run.json"
        if not metadata_path.exists():
            return {}

        try:
            with metadata_path.open("r", encoding="utf-8") as handle:
                raw = handle.read()
            if not raw.strip():
                return {}
            return json.loads(raw)
        except Exception as exc:  # pragma: no cover - defensive logging
            print(f"⚠️ Failed to read {metadata_path}: {exc}")
            return {}


# ---------------------------------------------------------------------------
# Statistics building blocks
# ---------------------------------------------------------------------------


class BaseStatistic:
    """Interface for statistics that can be rendered by the dashboard."""

    name: str

    def render_single(self, run: RunData) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError

    def render_trend(self, history: RunHistory) -> widgets.Widget:  # pragma: no cover - UI
        raise NotImplementedError


def _stat_card(title: str, value: str, description: str | None = None) -> widgets.Widget:
    body = [
        f"<div style='font-size:12px;color:#666;'>{title}</div>",
        f"<div style='font-size:26px;font-weight:bold;margin-top:6px;'>{value}</div>",
    ]
    if description:
        body.append(
            f"<div style='font-size:11px;color:#999;margin-top:4px;'>{description}</div>"
        )
    html = "".join(body)
    return widgets.HTML(
        value=(
            "<div style='padding:12px 16px;border:1px solid #ddd;border-radius:8px;"
            "min-width:160px;background:#fafafa;'>"
            f"{html}</div>"
        )
    )


class RecordCountStatistic(BaseStatistic):
    """Row-count statistic that adapts to snapshot and diff runs automatically."""

    def __init__(self) -> None:
        self.name = "记录数"
        self.description = "根据运行类型自动选择表格并统计行数"

    def _resolve_table_key(self, run: RunData) -> Optional[str]:
        run_type = (run.metadata or {}).get("run_type")
        if run_type == "snapshot":
            return "commit_files_df"
        if run_type == "diff":
            return "diff_results_df"

        if "commit_files_df" in run.dataframes:
            return "commit_files_df"
        if "diff_results_df" in run.dataframes:
            return "diff_results_df"
        return None

    def _extract(self, run: RunData) -> Optional[int]:
        table_key = self._resolve_table_key(run)
        if table_key is None:
            return None

        df = run.dataframes.get(table_key)
        if df is None:
            return None
        return int(df.shape[0])

    def render_single(self, run: RunData) -> widgets.Widget:
        value = self._extract(run)
        display_value = f"{value}" if value is not None else "N/A"
        return _stat_card(self.name, display_value, self.description)

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        for run in history.runs:
            value = self._extract(run)
            if value is not None:
                records.append(
                    {
                        "label": run.display_label,
                        "value": value,
                        "timestamp": run.timestamp,
                    }
                )

        if not records:
            return widgets.HTML(
                value=(
                    f"<div style='color:#666;'>暂无 {self.name} 的历史数据可以展示。</div>"
                )
            )

        df = pd.DataFrame(records)
        df.sort_values(by="timestamp", inplace=True)

        output = widgets.Output()
        with output:
            fig, ax = plt.subplots(figsize=(6, 3))
            ax.plot(df["label"], df["value"], marker="o")
            ax.set_title(self.name)
            ax.set_xlabel("Run")
            ax.set_ylabel("Count")
            ax.grid(True, linestyle="--", alpha=0.3)
            plt.xticks(rotation=30, ha="right")
            plt.tight_layout()
            display(fig)
            plt.close(fig)

        description = self.description
        return widgets.VBox(
            [
                widgets.HTML(
                    value=(
                        f"<b>{self.name}</b><div style='color:#666;font-size:11px;'>{description}</div>"
                    )
                ),
                output,
            ]
        )


class FileCharCountDistributionStatistic(BaseStatistic):
    """Bucket files by character count and highlight diff additions/modifications."""

    BINS: Sequence[tuple[str, int, Optional[int]]] = (
        ("<1k", 0, 1_000),
        ("1k-2k", 1_000, 2_000),
        ("2k-3k", 2_000, 3_000),
        ("3k-10k", 3_000, 10_000),
        ("10k-50k", 10_000, 50_000),
        (">=50k", 50_000, None),
    )

    def __init__(self) -> None:
        self.name = "文件字符区间"
        self.description = "基于 FileCharCount 分析结果统计字符区间，并区分新增/变更文件数量"

    # -- helpers -----------------------------------------------------------

    def _load_char_counts(self, run: RunData) -> Optional[pd.DataFrame]:
        df = run.dataframes.get("analysis_results_df")
        if df is None or df.empty:
            return None

        if "analyzer_type" not in df.columns or "count" not in df.columns:
            return None

        filtered = df[df["analyzer_type"] == "FileCharCount"].copy()
        if filtered.empty:
            return None

        filtered["count"] = pd.to_numeric(filtered["count"], errors="coerce")
        filtered.dropna(subset=["count"], inplace=True)
        if filtered.empty:
            return None

        if "commit_hash" not in filtered.columns:
            filtered["commit_hash"] = ""
        else:
            filtered["commit_hash"] = filtered["commit_hash"].fillna("").astype(str)

        if "path" not in filtered.columns:
            filtered["path"] = ""
        else:
            filtered["path"] = filtered["path"].fillna("").astype(str)
        return filtered

    def _attach_diff_metadata(self, run: RunData, df: pd.DataFrame) -> tuple[pd.DataFrame, str, bool]:
        run_type = (run.metadata or {}).get("run_type", "")
        df = df.copy()
        diff_info_available = False

        if run_type == "diff":
            diff_df = run.dataframes.get("diff_results_df")
            if diff_df is not None and not diff_df.empty:
                diff_df = diff_df.copy()
                for column in ("target_commit_hash", "target_path", "diff_change_type"):
                    if column not in diff_df.columns:
                        diff_df[column] = ""
                diff_df["target_commit_hash"] = diff_df["target_commit_hash"].fillna("").astype(str)
                diff_df["target_path"] = diff_df["target_path"].fillna("").astype(str)
                diff_df["diff_change_type"] = diff_df["diff_change_type"].fillna("").astype(str)

                target_commits = {
                    value for value in diff_df["target_commit_hash"].tolist() if value
                }
                if target_commits:
                    df = df[df["commit_hash"].isin(target_commits)].copy()

                diff_map = diff_df[["target_commit_hash", "target_path", "diff_change_type"]].rename(
                    columns={
                        "target_commit_hash": "commit_hash",
                        "target_path": "path",
                    }
                )

                df = df.merge(diff_map, on=["commit_hash", "path"], how="left")
                if "diff_change_type" in df.columns:
                    df["diff_change_type"] = df["diff_change_type"].replace("", pd.NA)
                    if df["diff_change_type"].notna().any():
                        diff_info_available = True
            else:
                df["diff_change_type"] = pd.NA
        else:
            df["diff_change_type"] = pd.NA

        return df, str(run_type), diff_info_available

    def _bucket_label(self, value: float) -> str:
        for label, lower, upper in self.BINS:
            if value < lower:
                continue
            if upper is None or value < upper:
                return label
        return self.BINS[-1][0]

    def _summaries(self, run: RunData) -> Optional[dict[str, object]]:
        base_df = self._load_char_counts(run)
        if base_df is None:
            return None

        df, run_type, diff_info_available = self._attach_diff_metadata(run, base_df)
        if df.empty:
            return None

        df["range_label"] = df["count"].apply(self._bucket_label)

        rows: List[dict[str, object]] = []
        for label, _, _ in self.BINS:
            subset = df[df["range_label"] == label]
            total = int(subset.shape[0])
            added: Optional[int] = None
            changed: Optional[int] = None

            if run_type == "diff" and diff_info_available:
                added = int(subset["diff_change_type"].isin({"A"}).sum())
                changed = int(subset["diff_change_type"].isin({"M", "R"}).sum())

            rows.append(
                {
                    "range": label,
                    "total": total,
                    "added": added,
                    "changed": changed,
                }
            )

        return {
            "rows": rows,
            "run_type": run_type,
            "diff_info": diff_info_available,
        }

    def _render_distribution_table(self, rows: Sequence[dict[str, object]], diff_info: bool) -> widgets.HTML:
        header_cells = ["区间", "文件数", "新增", "变更"]
        html = [
            "<table style='border-collapse:collapse;font-size:12px;width:100%;max-width:520px;'>",
            "<thead><tr>",
        ]
        for cell in header_cells:
            html.append(
                f"<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:left;color:#555;font-weight:600;'>{cell}</th>"
            )
        html.append("</tr></thead><tbody>")

        for row in rows:
            total = row["total"]
            added = row.get("added")
            changed = row.get("changed")
            html.append("<tr>")
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{row['range']}</td>"
            )
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{total}</td>"
            )
            if diff_info:
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{added if added is not None else 0}</td>"
                )
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{changed if changed is not None else 0}</td>"
                )
            else:
                html.append(
                    "<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#999;'>-</td>"
                )
                html.append(
                    "<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#999;'>-</td>"
                )
            html.append("</tr>")

        html.append("</tbody></table>")
        return widgets.HTML(value="".join(html))

    def _render_matrix_table(
        self, title: str, df: pd.DataFrame, label_order: Sequence[str]
    ) -> widgets.HTML:
        if df.empty:
            return widgets.HTML(value="")

        df = df.copy()
        df = df.reindex(self._bin_labels(), axis=0, fill_value=0)
        df = df[[label for label in label_order if label in df.columns]]

        html = [
            f"<div style='font-size:12px;color:#555;font-weight:600;margin:8px 0 4px;'>{title}</div>",
            "<table style='border-collapse:collapse;font-size:12px;width:100%;max-width:720px;'>",
            "<thead><tr>",
            "<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:left;color:#555;font-weight:600;'>区间</th>",
        ]
        for col in df.columns:
            html.append(
                f"<th style='border-bottom:1px solid #ddd;padding:6px 8px;text-align:right;color:#555;font-weight:600;'>{col}</th>"
            )
        html.append("</tr></thead><tbody>")

        for idx in df.index:
            html.append("<tr>")
            html.append(
                f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;'>{idx}</td>"
            )
            for col in df.columns:
                value = int(df.loc[idx, col]) if pd.notna(df.loc[idx, col]) else ""
                html.append(
                    f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;color:#333;text-align:right;'>{value}</td>"
                )
            html.append("</tr>")

        html.append("</tbody></table>")
        return widgets.HTML(value="".join(html))

    def _bin_labels(self) -> List[str]:
        return [label for label, _, _ in self.BINS]

    # -- rendering ---------------------------------------------------------

    def render_single(self, run: RunData) -> widgets.Widget:
        summary = self._summaries(run)
        if summary is None:
            return widgets.HTML(
                value=(
                    "<div style='color:#666;'>暂无 FileCharCount 分析结果可用于统计。</div>"
                )
            )

        header = widgets.HTML(
            value=f"<b>{self.name}</b><div style='color:#666;font-size:11px;'>{self.description}</div>"
        )
        table = self._render_distribution_table(
            summary["rows"], summary["run_type"] == "diff" and summary["diff_info"]
        )
        return widgets.VBox([header, table])

    def render_trend(self, history: RunHistory) -> widgets.Widget:
        records: List[dict[str, object]] = []
        label_order: List[str] = []
        seen_labels: set[str] = set()
        diff_info_available = False

        for run in history.runs:
            summary = self._summaries(run)
            if summary is None:
                continue

            label = run.display_label
            if label not in seen_labels:
                label_order.append(label)
                seen_labels.add(label)

            for row in summary["rows"]:
                records.append(
                    {
                        "range": row["range"],
                        "total": row["total"],
                        "added": row.get("added"),
                        "changed": row.get("changed"),
                        "label": label,
                        "run_type": summary["run_type"],
                        "diff_info": summary["diff_info"],
                    }
                )

            if summary["run_type"] == "diff" and summary["diff_info"]:
                diff_info_available = True

        if not records:
            return widgets.HTML(
                value=(
                    "<div style='color:#666;'>暂无 FileCharCount 历史数据可以展示。</div>"
                )
            )

        df = pd.DataFrame(records)
        df["range"] = pd.Categorical(df["range"], categories=self._bin_labels(), ordered=True)

        pivot_total = (
            df.pivot_table(
                index="range", columns="label", values="total", aggfunc="sum", fill_value=0
            )
            if not df.empty
            else pd.DataFrame()
        )

        header = widgets.HTML(
            value=f"<b>{self.name}</b><div style='color:#666;font-size:11px;'>{self.description}</div>"
        )
        children: List[widgets.Widget] = [header]

        if not pivot_total.empty:
            children.append(self._render_matrix_table("各运行的文件数量分布", pivot_total, label_order))

        if diff_info_available:
            diff_df = df[(df["run_type"] == "diff") & (df["diff_info"])]
            if not diff_df.empty:
                pivot_added = diff_df.pivot_table(
                    index="range",
                    columns="label",
                    values="added",
                    aggfunc="sum",
                    fill_value=0,
                )
                pivot_changed = diff_df.pivot_table(
                    index="range",
                    columns="label",
                    values="changed",
                    aggfunc="sum",
                    fill_value=0,
                )

                if not pivot_added.empty:
                    children.append(
                        self._render_matrix_table("新增文件分布", pivot_added, label_order)
                    )
                if not pivot_changed.empty:
                    children.append(
                        self._render_matrix_table("变更文件分布", pivot_changed, label_order)
                    )

        if len(children) == 1:
            children.append(
                widgets.HTML(value="<div style='color:#666;'>暂无可视化数据。</div>")
            )

        return widgets.VBox(children)


# ---------------------------------------------------------------------------
# Dashboard orchestration
# ---------------------------------------------------------------------------


@dataclass
class _RepoPage:
    repo: str
    single_run_selector: widgets.Dropdown
    trend_run_selector: widgets.SelectMultiple
    single_container: widgets.Box
    trend_container: widgets.Box
    tab: widgets.Tab
    container: widgets.VBox
    history: Optional[RunHistory] = None


class QuickstartDashboard:
    """High-level dashboard that wires selectors, statistics and layout."""

    def __init__(
        self,
        base_dir: str | Path = "../artifacts",
        statistics: Optional[Sequence[BaseStatistic]] = None,
        loader: Optional[RunDataLoader] = None,
    ) -> None:
        self.loader = loader or RunDataLoader(base_dir=base_dir)
        self.statistics: List[BaseStatistic] = list(statistics or [])
        self.repo_pages: List[_RepoPage] = []
        self._root: widgets.Widget | None = None

    # -- public API ----------------------------------------------------

    def register_statistic(self, stat: BaseStatistic) -> None:
        self.statistics.append(stat)

    def widget(self) -> widgets.Widget:
        """Return the root widget without triggering an automatic display."""

        if self._root is None:
            self._root = self._build()
        return self._root

    def show(self) -> None:
        """Display the dashboard inside the current notebook output cell."""

        display(self.widget())

    def refresh(self) -> None:
        """Reload repository information and update the UI."""

        if self._root is None:
            self._root = self._build()
        else:
            self._root.children = tuple(self._build().children)

    # -- building ------------------------------------------------------

    def _build(self) -> widgets.Widget:
        repos = self.loader.list_repos()
        if not repos:
            return widgets.VBox(
                [
                    widgets.HTML(
                        value=(
                            "<b>未发现任何分析结果</b><br>"
                            "请先运行 Git2Base 并确认结果已保存在 artifacts 目录下。"
                        )
                    )
                ]
            )

        self.repo_pages = [self._create_repo_page(repo) for repo in repos]

        tab = widgets.Tab(children=[page.container for page in self.repo_pages])
        for index, page in enumerate(self.repo_pages):
            tab.set_title(index, page.repo)

        return widgets.VBox([tab])

    def _create_repo_page(self, repo: str) -> _RepoPage:
        runs = self.loader.list_runs(repo)
        single_selector = widgets.Dropdown(
            options=runs,
            description="Run:",
            layout=widgets.Layout(width="60%"),
        )
        trend_selector = widgets.SelectMultiple(
            options=runs,
            description="Runs:",
            layout=widgets.Layout(width="60%", height="120px"),
        )

        single_container = widgets.Box(
            layout=widgets.Layout(display="flex", flex_flow="row wrap", gap="12px")
        )
        trend_container = widgets.Box(
            layout=widgets.Layout(display="flex", flex_flow="column", gap="18px")
        )

        single_panel = widgets.VBox(
            [single_selector, single_container], layout=widgets.Layout(gap="12px")
        )
        trend_panel = widgets.VBox(
            [trend_selector, trend_container], layout=widgets.Layout(gap="12px")
        )

        tabs = widgets.Tab(children=[single_panel, trend_panel])
        tabs.set_title(0, "单次执行统计")
        tabs.set_title(1, "趋势分析")

        container = widgets.VBox([tabs])
        page = _RepoPage(
            repo=repo,
            single_run_selector=single_selector,
            trend_run_selector=trend_selector,
            single_container=single_container,
            trend_container=trend_container,
            tab=tabs,
            container=container,
        )

        self._initialize_repo_page(page)

        def _on_single_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_single_statistics(page)

        def _on_trend_change(change: dict) -> None:
            if change.get("name") == "value":
                self._update_trend_statistics(page)

        single_selector.observe(_on_single_change, names="value")
        trend_selector.observe(_on_trend_change, names="value")
        return page

    # -- updating ------------------------------------------------------

    def _initialize_repo_page(self, page: _RepoPage) -> None:
        page.history = self.loader.load_history(page.repo)
        runs = [run.run for run in (page.history.runs if page.history else [])]

        page.single_run_selector.options = runs
        page.trend_run_selector.options = runs

        if runs:
            if page.single_run_selector.value not in runs:
                page.single_run_selector.value = runs[0]
            if not page.trend_run_selector.value:
                page.trend_run_selector.value = tuple(runs)
        else:
            page.single_run_selector.value = None
            page.trend_run_selector.value = ()

        self._update_single_statistics(page)
        self._update_trend_statistics(page)

    def _update_single_statistics(self, page: _RepoPage) -> None:
        run_name = page.single_run_selector.value
        if not run_name:
            page.single_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择一个运行。</div>"),
            )
            return

        run_data: Optional[RunData] = None
        if page.history:
            for candidate in page.history.runs:
                if candidate.run == run_name:
                    run_data = candidate
                    break

        if run_data is None:
            run_data = self.loader.load_run(page.repo, run_name)

        if run_data is None:
            page.single_container.children = (
                widgets.HTML(
                    value="<div style='color:#d33;'>无法加载该运行的结果，请检查文件是否存在。</div>"
                ),
            )
            return

        single_widgets = [stat.render_single(run_data) for stat in self.statistics]
        if not single_widgets:
            single_widgets = [
                widgets.HTML(
                    value="<div style='color:#666;'>暂无统计卡片，请通过 register_statistic 添加。</div>"
                )
            ]
        page.single_container.children = tuple(single_widgets)

    def _update_trend_statistics(self, page: _RepoPage) -> None:
        if page.history is None:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>无可展示的历史数据。</div>"),
            )
            return

        selected_runs = list(page.trend_run_selector.value or [])
        if not selected_runs:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>请选择至少一个运行以展示趋势。</div>"),
            )
            return

        selected = set(selected_runs)
        filtered_runs = [run for run in page.history.runs if run.run in selected]
        if not filtered_runs:
            page.trend_container.children = (
                widgets.HTML(value="<div style='color:#666;'>所选运行没有历史数据。</div>"),
            )
            return

        filtered_history = RunHistory(repo=page.repo, runs=list(filtered_runs))
        filtered_history.ensure_sorted()

        trend_widgets = [stat.render_trend(filtered_history) for stat in self.statistics]
        if not trend_widgets:
            trend_widgets = [
                widgets.HTML(
                    value="<div style='color:#666;'>暂无趋势统计，请通过 register_statistic 添加。</div>"
                )
            ]
        page.trend_container.children = tuple(trend_widgets)


__all__ = [
    "BaseStatistic",
    "FileCharCountDistributionStatistic",
    "QuickstartDashboard",
    "RecordCountStatistic",
    "RunData",
    "RunDataLoader",
    "RunHistory",
]

